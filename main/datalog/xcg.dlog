# Custom call graph construction
# name=xcg-dlog

.include "M.dom"
.include "V.dom"
.include "H.dom"
.include "F.dom"
.include "I.dom"
.include "T.dom"
.include "Z.dom"

.bddvarorder I0xM0xM1_T0_V0xV1_T1_H0_F0_H1_Z0

# RELATIONS ===================================================================

Assign(v:V,u:V) input
Alloc(v:V,h:H) input
Load(y:V,x:V,f:F) input
Store(u:V,f:F,v:V) input
LoadStat(y:V,f:F) input
StoreStat(f:F,v:V) input
IinvkRet(i:I,n:Z,v:V) input
IinvkArg(i:I,n:Z,v:V) input
MmethArg(m:M,z:Z,v:V) input
MmethRet(m:M,z:Z,v:V) input

VT(v:V,t:T) input
HT(h:H,t:T) input
FT(f:F,t:T) input
Stub(m:M) input
cha(n:M1,t:T1,m:M0) input
sub(s:T1,t:T0) input
virtIM(i:I,m:M) input
nonVirtIM(i:I,m:M) input

VHfilter(v:V,h:H)
VV(v:V,u:V)
VH(v:V,h:H) output
HFH(h1:H,f:F,h2:H) output
FH(f:F,h:H)

cast(v:V,s:T,t:T)
dV(v:V,t:T) output
dHF(h:H,f:F,t:T) output
dHF_all(h:H) output
dF(f:F,t:T)

xIM(i:I,m:M) output

# RULES =======================================================================

# Base rules

VHfilter(v,h) :- VT(v,t), HT(h,s), sub(s,t).
VHfilter(_,0).
VV(v,u) :- IinvkArg(i,z,u), xIM(i,m), MmethArg(m,z,v).
VV(u,v) :- IinvkRet(i,z,u), xIM(i,m), MmethRet(m,z,v).

xIM(i,m2) :- virtIM(i,m1), IinvkArg(i,0,v), VH(v,h), HT(h,t), cha(m1,t,m2).
xIM(i,m) :- nonVirtIM(i,m).

VH(u,h) :- VV(u,v), VH(v,h), VHfilter(u,h).
VH(l,h) :- Alloc(l,h), VHfilter(l,h).
VH(l,h) :- Assign(l,r), VH(r,h), VHfilter(l,h).
VH(l,h2) :- Load(l,b,f), VH(b,h1), HFH(h1,f,h2), VHfilter(l,h2).
HFH(h1,f,h2) :- Store(b,f,r), VH(b,h1), VH(r,h2).
VH(l,h) :- LoadStat(l,f), FH(f,h), VHfilter(l,h).
FH(f,h) :- StoreStat(f,r), VH(r,h).

# Propagating down-closed values

cast(v,s1,s2) :- VT(v,t), sub(s1,t), s1 = s2. # upcast does nothing
cast(v,s,t) :- VT(v,t), sub(t,s). # downcast moves the upper bound lower

xIM(i,m2) :- virtIM(i,m1), IinvkArg(i,0,v), dV(v,t), sub(s,t), cha(m1,s,m2).

dV(u,t) :- VV(u,v), dV(v,s), cast(u,s,t).
# ignore allocation statements
dV(l,t) :- Assign(l,r), dV(r,s), cast(l,s,t).
dV(l,t) :- Load(l,b,f), dV(b,_), FT(f,s), cast(l,s,t). # the field must exist
dV(l,t) :- Load(l,b,f), VH(b,h), dHF(h,f,s), cast(l,s,t).
dV(l,t) :- Load(l,b,f), VH(b,h), dHF_all(h), FT(f,s), cast(l,s,t).
dHF(h,f,t) :- Store(b,f,r), VH(b,h), dV(r,t). # always dc_type(r) <: stat_type(r) <: type(f)
# ignore case where dV(b,_)
dV(l,t) :- LoadStat(l,f), dF(f,s), cast(l,s,t).
dF(f,t) :- StoreStat(f,r), dV(r,t). # always dc_type(r) <: stat_type(r) <: type(f)

# Introducing down-closed values

dHF_all(h) :- IinvkArg(i,_,v), xIM(i,m), Stub(m), VH(v,h).
dHF_all(h2) :- dHF_all(h1), HFH(h1,_,h2). # also corrupt all recursively reachable objects
dV(u,t) :- IinvkRet(i,z,u), xIM(i,m), Stub(m), MmethRet(m,z,v), VT(v,s), cast(u,s,t).
