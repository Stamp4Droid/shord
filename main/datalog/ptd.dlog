##################
# Points-to analysis
##################

# name=ptd-dlog

.include "M.dom"
.include "C.dom"
.include "V.dom"
.include "H.dom"
.include "F.dom"
.include "I.dom"

.bddvarorder M0_C0xC1_V0xV1_H0xH1xF0_I0

Assign(v:V,u:V)     input   # v = u
Alloc(v:V,h:H)      input   # v is the lhs in the new stmt h
Load(y:V,x:V,f:F)   input   # y = x.f
Store(u:V,f:F,v:V)  input   # u.f = v
param(u:V,v:V,i:I)  input   # u is the formal parameter, v is actual arg, i is invocation stmt
return(u:V,v:V,i:I) input   # u is the lhs at callsite, v is the return var, i is invocation stmt

MV(m:M,v:V) input         # v is a variable in method m
CM(c:C,m:M) input         # c is a context of method m
CH(o:C,h:H) input         # contextâ€™ified abstract location o corresponds to new stmt h
CI(c:C,i:I) input         # stmt i is the top element in the k-limited callstack c
CC(c:C,d:C) input         # there exists i s.t. c++[i] = d

ptd(c:C,v:V,h:H)    output # (c,v) points-to o
fptd(h1:H,f:F,h2:H) output

ptdf(v:V,h:H) output

###################
#    RULES
###################

ptd(c,v,h) :- Alloc(v,h), MV(m,v), CM(c,m).

ptd(c,v,h) :- ptd(c,u,h), Assign(v,u).
ptd(d,u,h) :- ptd(c,v,h), param(u,v,i), CC(c,d), CI(d,i).
ptd(c,u,h) :- ptd(d,v,h), return(u,v,i), CI(d,i), CC(c,d).

fptd(h1,f,h2) :- ptd(c,v,h2), Store(u,f,v), ptd(c,u,h1).
ptd(c,y,h2) :- ptd(c,x,h1), Load(y,x,f), fptd(h1,f,h2).

ptdf(v,h) :- ptd(_,v,h).
