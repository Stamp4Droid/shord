##################
# K-obj Points-to analysis
##################

# name=pt-obj-dlog

.include "M.dom"
.include "C.dom"
.include "V.dom"
.include "H.dom"
.include "F.dom"
.include "I.dom"
.include "S.dom"
.include "T.dom"
.include "Z.dom"

#.bddvarorder C0xC1_V0xV1_H0_F0_I0_T0_T1_M0_S0_M1_Z0
.bddvarorder F0_I0xM0_S0_T0_V0xV1_T1_H0_C0xC1xC2_Z0
#.bddvarorder S0_T0_V0xV1_T1_H0_C0xC1xC2_F0xI0xM0_Z0

Assign(v:V,u:V)      input   # v = u
Alloc(v:V,h:H)       input   # v is the lhs in the new stmt h
GlobalAlloc(v:V,h:H) input   # v is the lhs in the new stmt h
Load(y:V,x:V,f:F)    input   # y = x.f
Store(u:V,f:F,v:V)   input   # u.f = v
LoadStat(y:V,f:F)    input   # y = f
StoreStat(f:F,v:V)   input   # f = v
param(u:V,v:V,i:I)   input   # u is the formal parameter, v is actual arg, i is invocation stmt
return(u:V,v:V,i:I) input   # u is the lhs at callsite, v is the return var, i is invocation stmt
typeFilter(v:V,o:C) input   # type wise, v can point-to o
ipFilter(c:C,v:V,o:C) input  
IinvkArg(i:I,n:Z,v:V) input

MV(m:M,v:V) input         # v is a variable in method m
#CM(c:C,m:M) input         # c is a context of method m
CH(o:C,h:H) input         # contextâ€™ified abstract location o corresponds to new stmt h
CC(c:C,d:C) input         # there exists i s.t. c++[i] = d
HT(h:H,t:T) input         # heap h point to Type t.
MI(m:M,i:I) input         # stmt i belongs to method m.
CI(c:C,i:I) input         # stmt i is on the top of c.

StatIM(i:I,m:M) input     # i statically invokes m. 
SpecIM(i:I,m:M) input     # i special invoke m. 
VirtIM(i:I,s:S) input     # i virtually invokes m. 
ClassT(t:T) input         # t is concrete or abstract
StaticTM(t:T,m:M) input   # m is a static method in t.
StaticTF(t:T,f:F) input   # f is a static field in t.
ClinitTM(t:T,m:M) input   # m is the class initializer in m.
Subtype(t1:T,t2:T) input    # t1 is a subtype of t2.
#CtxtInsMeth(m:M) input

#SubSig(m:M,s:S) input     # s is subsignature of m.
Dispatch(t:T,s:S,m:M) input     # t.m has subsig s.

#CICMtmp(d:C,i:I,c:C,m:M) output

###################
#    OUTPUT
###################
CIC(c:C,i:I,d:C) # d = [i, c]
reachableT(t:T) 
DIC(c:C,i:I,c:C) 
DVDV(c:C,u:V,d:C,v:V) 
reachableCI(c:C,i:I) 
reachableCM(c:C,m:M)   output
CICM(d:C,i:I,c:C,m:M)   output # i in cotext d calls method m in context c.
pt(c:C,v:V,o:C)    output # (c,v) points-to o
fpt(o1:C,f:F,o2:C) output
fptStat(f:F,o:C) 
ICM(i:I,c:C,m:M) 

###################
#    RULES
###################

pt(c,v,o) :- Assign(v,u), pt(c,u,o), typeFilter(v,o).

reachableCI(c,i) :- MI(m,i), reachableCM(c,m).

CIC(c,i,d) :- CC(c,d), CI(d,i).

DIC(c,i,o) :- IinvkArg(i,0,v), pt(c,v,o).
CICM(c,i,o,m) :- reachableCI(c,i), DIC(c,i,o), ICM(i,o,m). 
CICM(c,i,d,m) :- reachableCI(c,i), StatIM(i,m), CIC(c,i,d).
CICM(c,i,o,m) :- reachableCI(c,i), SpecIM(i,m), DIC(c,i,o).
#CICM(c,i,d,m) :- CICMtmp(c,i,d,m), !CtxtInsMeth(m).
#CICM(c,i,0,m) :- CICMtmp(c,i,_,m), CtxtInsMeth(m).

DVDV(d,u,c,v) :- CICM(c,i,d,m), MV(m,u), param(u,v,i).
DVDV(c,u,d,v) :- CICM(c,i,d,m), MV(m,v), return(u,v,i).

pt(c,u,o) :- DVDV(c,u,d,v), pt(d,v,o), ipFilter(c,u,o).

pt(c,v,o) :- Alloc(v,h), MV(m,v), reachableCM(c,m), CC(c,o), CH(o,h).
pt(c,v,o) :- GlobalAlloc(v,h), MV(m,v), reachableCM(c,m), CH(o,h).

fpt(o1,f,o2) :- pt(c,v,o2), Store(u,f,v), pt(c,u,o1).
pt(c,y,o2) :- pt(c,x,o1), Load(y,x,f), fpt(o1,f,o2). 

fptStat(f,o) :- pt(_,v,o), StoreStat(f,v).
pt(c,y,o) :- LoadStat(y,f), fptStat(f,o), MV(m,y), reachableCM(c,m).

reachableT(t) :- reachableCM(_,m), MV(m,v), Alloc(v,h), HT(h,t).
reachableT(t) :- reachableCM(_,m), StaticTM(t,m).
reachableT(t) :- reachableCM(_,m), MV(m,v), StoreStat(f,v), StaticTF(t,f).
reachableT(t) :- reachableCM(_,m), MV(m,v), LoadStat(v,f), StaticTF(t,f).
reachableT(t) :- ClassT(t), reachableT(s), Subtype(s,t).

reachableCM(0,0).
reachableCM(0,m) :- ClinitTM(t,m), reachableT(t).
reachableCM(c,m) :- CICM(_,_,c,m). 

ICM(i,o,m2) :- VirtIM(i,s), Dispatch(t,s,m2), HT(h,t), CH(o,h).
