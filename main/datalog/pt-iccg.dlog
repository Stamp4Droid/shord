##################
# Points-to analysis
##################

# name=pt-iccg-dlog

.include "M.dom"
.include "I.dom"
.include "T.dom"
.include "Z.dom"
.include "V.dom"
.include "C.dom"

.bddvarorder M0xM1_I0_T0_Z0_V0_C0xC1

IinvkArg(i:I,n:Z,v:V) input
MmethArg(m:M,z:Z,v:V) input
pt(c:C,v:V,o:C)    input
chaIM(i:I,m:M) input      # stmt i invokes method m.
MI(m:M,i:I) input         # stmt i belongs to method m.
MC(m:M,c:T) input         # m is a method declared in a
Callbacks(m:M) input
MregI(m:M,i:I) input
CM(c:C,m:M) input      # c is a context of method m.
CI(c:C,i:I) input         # stmt i is the top element in the k-limited callstack c
CC(c:C,d:C) input         # there exists i s.t. c++[i] = d

#MM(m1:M,m2:M)         output  # m1 calls m2
MM(k1:C,m1:M,k2:C,m2:M)         output  # m1 calls m2
#CallerComp(m:M,c:T)   output  # m is a method declared in c
CallerComp(m:M,c:C,o:T)   output  # m is a method declared in c

###################
#    RULES
###################

#MM(k1,m1,k2,m2) :- MI(m1,i), chaIM(i,m2), IinvkArg(i,0,a), pt(k1,a,k2).
MM(k1,m1,k2,m2) :- MI(m1,i), chaIM(i,m2), CI(k2,i), CC(k1,k2). 
CallerComp(m,k,c) :- MC(m,c), CM(k,m).
CallerComp(m2,k2,c) :- CallerComp(m1,k1,c), MM(k1,m1,k2,m2).
CallerComp(cb,k2,c) :- Callbacks(cb), MmethArg(cb,0,p), pt(k2,p,o), pt(k1,a,o), CallerComp(m,k1,c), MregI(m,i), IinvkArg(i,0,a).

#old version
#MM(m1,m2) :- MI(m1,i), chaIM(i,m2).
#CallerComp(m,c) :- MC(m,c).
#CallerComp(m2,c) :- MM(m1,m2), CallerComp(m1,c).
#CallerComp(cb,c) :- Callbacks(cb), MmethArg(cb,0,p), pt(_,p,o), pt(_,a,o), CallerComp(m,c), MregI(m,i), IinvkArg(i,0,a).


#MM(m1,m2) :- MI(m1,i), chaIM(i,m2), MmethArg(m1,0,p), IinvkArg(i,1,a), pt(_,p,o), pt(_,a,o).
#CallerComp(m2,c) :- CallerComp(m1,c), MI(m1,i), chaIM(i,m2), MmethArg(m2,0,p), IinvkArg(i,0,a), pt(_,p,o), pt(_,a,o).
#CallerComp(cb,c) :- Callbacks(cb), MmethArg(cb,z,p), pt(_,p,o), pt(_,a,o), CallerComp(m,c), MregI(m,i), IinvkArg(i,z,a).
