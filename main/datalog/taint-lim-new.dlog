# CONFIGURATION ===============================================================

# name=taint-lim-new-dlog

.include "Z.dom"
.include "M.dom"
.include "C.dom"
.include "V.dom"
.include "U.dom"
.include "H.dom"
.include "F.dom"
.include "I.dom"
.include "L.dom"
.include "CL.dom"

.bddvarorder L0_Z0xZ1_M0_CL0xCL1_C0xC1_V0xV1_U0xU1_H0xF0_I0

# INPUT RELATIONS =============================================================

Alloc(v:V,h:H)      input   # v is the lhs in the new stmt h
Assign(v:V,u:V)     input   # v = u
Load(y:V,x:V,f:F)   input   # y = x.f
Store(u:V,f:F,v:V)  input   # u.f = v
LoadStat(y:V,f:F)   input   # y = f
StoreStat(f:F,v:V)  input   # f = v
param(u:V,v:V,i:I)  input   # u is the formal parameter, v is actual arg, i is invocation stmt
return(u:V,v:V,i:I) input   # u is the lhs at callsite, v is the return var, i is invocation stmt
typeFilter(v:V,o:C) input   # type wise, v can point-to o

AssignPrim(v:U,u:U)     input # v = u
LoadPrim(y:U,x:V,f:F)   input # y = x.f
StorePrim(u:V,f:F,v:U)  input # u.f = v
LoadStatPrim(y:U,f:F)   input # y = f
StoreStatPrim(f:F,v:U)  input # f = v
paramPrim(u:U,v:U,i:I)  input # u: formal param, v: actual arg, i: invocation stmt
returnPrim(u:U,v:U,i:I) input # u: lhs at callsite, v: return var, i: invocation stmt

MV(m:M,v:V) input # v is a variable in method m
MU(m:M,u:U) input # u is a prim type variable in m
CM(c:C,m:M) input # c is a context of method m
CH(o:C,h:H) input # contextâ€™ified abstract location o corresponds to new stmt h
CI(c:C,i:I) input # stmt i is the top element in the k-limited callstack c
CC(c:C,d:C) input # there exists i s.t. c++[i] = d
CCL(c:C,cl:CL) input 
LCL(l:L,cl:CL) input

sinkCtxtLabel(l:CL) input
srcCtxtLabel(l:CL) input

InLabelRet(l:L,m:M)           input
InLabelArg(l:L,m:M,z:Z)       input
OutLabelRet(l:L,m:M)          input
OutLabelArg(l:L,m:M,z:Z)      input
ArgRetTransfer(m:M,z:Z)       input
ArgArgTransfer(m:M,z0:Z,z1:Z) input
ArgArgFlow(m:M,z0:Z,z1:Z)     input

MmethArg(m:M,z:Z,v:V)     input
MmethRet(m:M,z:Z,v:V)     input
MmethPrimArg(m:M,z:Z,u:U) input
MmethPrimRet(m:M,z:Z,u:U) input

# INTERMEDIATE RELATIONS ======================================================

# 0-cfa relations
pt0(v:V,o:C) output
fpt0(op:C,f:F,o:C) output

# k-cfa relations
ptk(c:C,v:V,o:C) output
fptk(op:C,f:F,o:C) output
queryObj(o:C) output
queryRef(v:V) output
queryRefCtxt(c:C,v:V) output

# annotations

varInLabel(v:V,l:L)
varInLabelPrim(v:U,l:L)
varOutLabel(v:V,l:L)
varOutLabelPrim(v:U,l:L)

transferRefRef(u:V,v:V)
transferPrimRef(u:U,v:V)
transferRefPrim(u:V,v:U)
transferPrimPrim(u:U,v:U)

flowRefRef(u:V,v:V)
flowPrimRef(u:U,v:V)
flowRefPrim(u:V,v:U)
flowPrimPrim(u:U,v:U)

transferObjRef(o:C,c:C,v:V)
transferObjPrim(o:C,c:C,u:U)

# label flow

labelIn(o:C,l:CL)            # l inductively reaches o from a directly-labeled value
labelXferOut(o:C,l:CL)       # l inductively reaches o from a value tainted by a passthrough
label(o:C,l:CL)              # o is labeled with l

labelPrimFld(o:C,f:F,l:CL)   # prim fld f of object o is labeled l
labelPrimFldStat(f:F,l:CL)   # static field f of primitive type has label l

sink(o:C,l:CL)               # o escapes into sink l
sinkPrim(c:C,u:U,l:CL)       # (c,u) escapes into sink l

# OUTPUT RELATIONS ============================================================

labelRef(c:C,v:V,l:CL)  output # (c,v) is labeled with l
labelPrim(c:C,u:U,l:CL) output # (c,u) is labeled with l
flow(src:CL,sink:CL) output

# PT RULES ====================================================================

##############
# 0-CFA pt
##############

# pt rules
pt0(v,o) :- Alloc(v,h), typeFilter(v,o), CH(o,h).
pt0(u,o) :- pt0(v,o), Assign(u,v), typeFilter(u,o).
pt0(u,o) :- pt0(v,o), param(u,v,_), typeFilter(u,o).
pt0(u,o) :- pt0(v,o), return(u,v,_), typeFilter(u,o).
fpt0(op,f,o) :- pt0(v,o), Store(u,f,v), pt0(u,op).
pt0(x,o) :- fpt0(op,f,o), pt0(w,op), Load(x,w,f), typeFilter(x,o).
pt0(u,o) :- pt0(v,o), StoreStat(f,v), LoadStat(u,f), typeFilter(u,o).

##############
# k-CFA pt
##############

# pt rules
ptk(c,v,o) :- queryObj(o), Alloc(v,h), MV(m,v), pt0(v,o), CM(c,m), CC(c,o), CH(o,h).
ptk(c,u,o) :- ptk(c,v,o), Assign(u,v), pt0(u,o).
ptk(d,u,o) :- ptk(c,v,o), param(u,v,i), pt0(u,o), CC(c,d), CI(d,i).
ptk(c,u,o) :- ptk(d,v,o), return(u,v,i), CI(d,i), CC(c,d), pt0(u,o).
fptk(op,f,o) :- ptk(c,v,o), Store(u,f,v), ptk(c,u,op), fpt0(op,f,o).
ptk(d,x,o) :- fptk(op,f,o), ptk(d,w,op), Load(x,w,f), pt0(x,o).
ptk(c,u,o) :- ptk(_,v,o), StoreStat(f,v), LoadStat(u,f), MV(m,u), CM(c,m), pt0(u,o).

# pt ref queries
queryRefCtxt(c,u) :- ptk(c,v,o), Store(u,f,v), pt0(u,op), pt0(w,op), Load(x,w,f), pt0(x,o).
queryRef(w) :- ptk(_,v,o), Store(u,f,v), pt0(u,op), pt0(w,op), Load(x,w,f), pt0(x,o).

# query rules
queryRef(u) :- queryRef(v), Assign(v,u).
queryRefCtxt(c,u) :- queryRef(v), param(v,u,i), CC(c,d), CI(d,i).
queryRefCtxt(d,u) :- queryRef(v), return(v,u,i), CI(d,i).

queryRef(u) :- queryRef(v), Load(v,u,f), pt0(u,op), pt0(w,op), Store(w,f,_).
queryRef(w) :- queryRef(v), Load(v,u,f), pt0(u,op), pt0(w,op), Store(w,f,_).

queryRefCtxt(d,x) :- queryRef(v), Load(v,u,f), ptk(_,u,op), ptk(d,w,op), Store(w,f,x).

ptk(c,v,o) :- queryRef(v), Load(v,u,f), ptk(c,u,op), ptk(d,w,op), Store(w,f,x), ptk(d,x,o), pt0(v,o).
ptk(c,v,o) :- queryRef(v), Alloc(v,h), MV(m,v), pt0(v,o), CM(c,m), CC(c,o), CH(o,h).

queryRef(u) :- queryRef(v), LoadStat(v,f), StoreStat(f,u).

ptk(c,v,o) :- queryRef(v), LoadStat(v,f), StoreStat(f,u), ptk(_,u,o), MV(m,v), CM(c,m), pt0(v,o).

# query rules
queryRefCtxt(c,u) :- queryRefCtxt(c,v), Assign(v,u).
queryRefCtxt(c,u) :- queryRefCtxt(d,v), param(v,u,i), CC(c,d), CI(d,i).
queryRefCtxt(d,u) :- queryRefCtxt(c,v), return(v,u,i), CI(d,i), CC(c,d).

queryRefCtxt(c,u) :- queryRefCtxt(c,v), Load(v,u,f), pt0(u,op), pt0(w,op), Store(w,f,_).
queryRef(w) :- queryRefCtxt(_,v), Load(v,u,f), pt0(u,op), pt0(w,op), Store(w,f,_).

queryRefCtxt(d,x) :- queryRefCtxt(c,v), Load(v,u,f), ptk(c,u,op), ptk(d,w,op), Store(w,f,x).

ptk(c,v,o) :- queryRefCtxt(c,v), Load(v,u,f), ptk(c,u,op), ptk(d,w,op), Store(w,f,x), ptk(d,x,o).
ptk(c,v,o) :- queryRefCtxt(c,v), Alloc(v,h), MV(m,v), pt0(v,o), CM(c,m), CC(c,o), CH(o,h).

queryRef(u) :- queryRefCtxt(_,v), LoadStat(v,f), StoreStat(f,u).

ptk(c,v,o) :- queryRefCtxt(c,v), LoadStat(v,f), StoreStat(f,u), ptk(_,u,o), MV(m,v), CM(c,m).

# RULES =======================================================================

# translation of annotation facts

varInLabel(v,l)     :- InLabelRet(l,m), MmethRet(m,_,v).
varInLabel(v,l)     :- InLabelArg(l,m,z), MmethArg(m,z,v).
varInLabelPrim(v,l) :- InLabelRet(l,m), MmethPrimRet(m,_,v).
varInLabelPrim(v,l) :- InLabelArg(l,m,z), MmethPrimArg(m,z,v).

varOutLabel(v,l)     :- OutLabelRet(l,m), MmethRet(m,_,v).
varOutLabel(v,l)     :- OutLabelArg(l,m,z), MmethArg(m,z,v).
varOutLabelPrim(v,l) :- OutLabelRet(l,m), MmethPrimRet(m,_,v).
varOutLabelPrim(v,l) :- OutLabelArg(l,m,z), MmethPrimArg(m,z,v).

transferRefRef(u,v)   :- ArgArgTransfer(m,z0,z1), MmethArg(m,z0,u), MmethArg(m,z1,v).
transferRefPrim(u,v)  :- ArgArgTransfer(m,z0,z1), MmethArg(m,z0,u), MmethPrimArg(m,z1,v).
transferPrimRef(u,v)  :- ArgArgTransfer(m,z0,z1), MmethPrimArg(m,z0,u), MmethArg(m,z1,v).
transferPrimPrim(u,v) :- ArgArgTransfer(m,z0,z1), MmethPrimArg(m,z0,u), MmethPrimArg(m,z1,v).

transferRefRef(u,v)   :- ArgRetTransfer(m,z), MmethArg(m,z,u), MmethRet(m,_,v).
transferRefPrim(u,v)  :- ArgRetTransfer(m,z), MmethArg(m,z,u), MmethPrimRet(m,_,v).
transferPrimRef(u,v)  :- ArgRetTransfer(m,z), MmethPrimArg(m,z,u), MmethRet(m,_,v).
transferPrimPrim(u,v) :- ArgRetTransfer(m,z), MmethPrimArg(m,z,u), MmethPrimRet(m,_,v).

flowRefRef(u,v)   :- ArgArgFlow(m,z0,z1), MmethArg(m,z0,u), MmethArg(m,z1,v).
flowRefPrim(u,v)  :- ArgArgFlow(m,z0,z1), MmethArg(m,z0,u), MmethPrimArg(m,z1,v).
flowPrimRef(u,v)  :- ArgArgFlow(m,z0,z1), MmethPrimArg(m,z0,u), MmethArg(m,z1,v).
flowPrimPrim(u,v) :- ArgArgFlow(m,z0,z1), MmethPrimArg(m,z0,u), MmethPrimArg(m,z1,v).

# (backward) escape flow

# abstract objects
# base escaping objects
sink(o,cl) :- varOutLabel(v,l), MV(m,v), CM(c,m), ptk(c,v,o), CCL(c,cl), LCL(l,cl).
# conditional escaping
sink(o,l)  :- ptk(c,u,o), flowRefRef(u,v), labelRef(c,v,l), sinkCtxtLabel(l).
sink(o,l)  :- ptk(c,u,o), flowRefPrim(u,v), labelPrim(c,v,l), sinkCtxtLabel(l).
# nested escaping (regular and conditional)
sink(o2,l) :- sink(o1,l), fptk(o1,_,o2).

# query rules
queryRef(v) :- varOutLabel(v,_).
queryRefCtxt(c,u) :- sinkCtxtLabel(l), labelRef(c,v,l), flowRefRef(u,v).
queryRefCtxt(c,u) :- sinkCtxtLabel(l), labelPrim(c,v,l), flowRefPrim(u,v).

# primitive-type variables/fields
# base escaping variables
sinkPrim(c,u,cl) :- varOutLabelPrim(u,l), CM(c,m), MU(m,u), LCL(l,cl), CCL(c,cl). 
# conditional escaping
sinkPrim(c,u,l) :- flowPrimRef(u,v), labelRef(c,v,l), sinkCtxtLabel(l).
sinkPrim(c,u,l) :- flowPrimPrim(u,v), labelPrim(c,v,l), sinkCtxtLabel(l).

# passthroughs

# base cases
transferObjRef(o,c,v)   :- transferRefRef(u,v), ptk(c,u,o).
transferObjPrim(o,c,v)  :- transferRefPrim(u,v), ptk(c,u,o).
# nested entry: behaves like nested escaping
transferObjRef(o2,c,v)  :- transferObjRef(o1,c,v), fptk(o1,0,o2).
transferObjPrim(o2,c,v) :- transferObjPrim(o1,c,v), fptk(o1,0,o2).

# passthroughs query rules
# ???

# complete flow

# basic connection of tainting and escaping
flow(src,sink) :- sink(o,sink), label(o,src), srcCtxtLabel(src).
flow(src,sink) :- sinkPrim(d,u,sink), labelPrim(d,u,src), srcCtxtLabel(src).
# nested escaping (regular and conditional)
flow(src,sink) :- sink(o,sink), labelPrimFld(o,_,src), srcCtxtLabel(src).

# (forward) label flow

# abstract objects
# label introduction
labelIn(o,cl)      :- varInLabel(v,l), MV(m,v), CM(c,m), ptk(c,v,o), CCL(c,cl), LCL(l,cl).
# nested tainting
labelIn(o2,l)      :- labelIn(o1,l), fptk(o1,_,o2).
label(o,l)         :- labelIn(o,l).
# passthrough handling
labelXferOut(o2,l) :- label(o1,l), transferObjRef(o1,c,v), ptk(c,v,o2).
labelXferOut(o,l)  :- labelPrim(c,u,l), transferPrimRef(u,v), ptk(c,v,o).
label(o,l)         :- labelXferOut(o,l).
# nested passthrough entry
labelXferOut(o2,l) :- labelPrimFld(o1,0,l), transferObjRef(o1,c,v), ptk(c,v,o2).
# nested passthrough exit
labelXferOut(o2,l) :- labelXferOut(o1,l), fptk(o1,0,o2).

# query rules
queryRef(v) :- varInLabel(v,_).
queryRef(v) :- label(o1,_), transferObjRef(o1,_,v).
queryRef(v) :- labelPrim(_,u,_), transferPrimRef(u,v).

queryObj(o) :- labelIn(o,_).
queryObj(o) :- labelXferOut(o,_).

# reference-type variables
# labels are tracked on the abstract objects, this is only for convenience
labelRef(c,v,l) :- ptk(c,v,o), label(o,l).

# primitive-type variables/fields
# label introduction
labelPrim(c,v,cl)     :- varInLabelPrim(v,l), CM(c,m), MU(m,v), LCL(l,cl), CCL(c,cl).
# label propagation
labelPrim(c,v,l)      :- AssignPrim(v,u), labelPrim(c,u,l).
labelPrimFld(o,f,l)   :- labelPrim(c,v,l), StorePrim(u,f,v), ptk(c,u,o).
labelPrim(c,y,l)      :- LoadPrim(y,x,f), labelPrimFld(o,f,l), ptk(c,x,o).
labelPrimFldStat(f,l) :- StoreStatPrim(f,v), labelPrim(_,v,l).
labelPrim(c,y,l)      :- LoadStatPrim(y,f), labelPrimFldStat(f,l), MU(m,y), CM(c,m).
labelPrim(d,u,l)      :- labelPrim(c,v,l), paramPrim(u,v,i), CC(c,d), CI(d,i).
labelPrim(c,u,l)      :- labelPrim(d,v,l), returnPrim(u,v,i), CI(d,i), CC(c,d).
# passthrough handling
labelPrim(c,v,l)      :- label(o,l), transferObjPrim(o,c,v).
labelPrim(c,v,l)      :- labelPrim(c,u,l), transferPrimPrim(u,v).
# nested tainting
labelPrim(c,y,l)      :- LoadPrim(y,x,_), labelIn(o,l), ptk(c,x,o).
# nested passthrough entry
labelPrim(c,v,l)      :- labelPrimFld(o,0,l), transferObjPrim(o,c,v).
# nested passthrough exit
labelPrim(c,y,l)      :- LoadPrim(y,x,0), labelXferOut(o,l), ptk(c,x,o).

# query rules
queryRef(u) :- labelPrim(_,v,_), StorePrim(u,_,v).

queryObj(o) :- LoadPrim(_,_,f), labelPrimFld(o,f,_).

## pt filter (temporary)

#pt(c:C,v:V,o:C) input
#ptFilter(c:C,v:V,o:C) output
#ptFilter(c,v,o) :- pt(c,v,o), ptk(c,v,o).

#fpt(o:C,f:F,op:C) input
#fptFilter(o:C,f:F,op:C) output
#fptFilter(o,f,op) :- fpt(o,f,op), fptk(o,f,op).
