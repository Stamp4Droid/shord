# Field-sensitive, k-CFA-based, variable-flow, taint-flow-based taint
# analysis.

# Derived from kcfa-hf-tf, with the added assumption that all variables are
# receivers in some object allocation (i.e., for each v, there exists some edge
# o cs_refAlloc v). This allows us to skip allocation information entirely.

# Additional rule splitting optimizations:
# - Inline 'Alias' rule
# - Group the LHS of some rules, in anticipation of LTR grouping
# - Force grouping of "DF cs_refLoad[f]"

# Handles:
# - [X] Points-to information
# - [X] Taint flow
#   - [X] Reference-type
#   - [X] Primitive-type
# - [X] Passthroughs
#   - [X] ref-to-ref
#   - [X] prim-to-prim
#   - [X] ref-to-prim
#   - [X] prim-to-ref
# - [-] Nested object tainting (ref, prim)
#   - [X] models tainting existing objects (arbitrarily deeply)
#   - [ ] models allocating (and arbitrarily sub-tainting) new objects
# - [X] Nested object escaping (ref, prim)
# - [ ] Nested passthrough taint (ref, prim)
# - [X] Non-full passthrough variants
# - ...

DF :: -
    | DF cs_refAssign
    | DF cs_refStore[f] _DF T2[f]
T2[f] :: DF cs_refLoad[f]

Src2Ref :: T1 _DF DF
T1 :: cs_srcRefFlow
    | Src2Ref cs_refRefFlow
    | Src2Ref _cs_refStore[*]
    | Src2Prim cs_primRefFlow

Src2Prim :: cs_srcPrimFlow
          | Src2Ref cs_primLoad[*]
          | Src2Ref cs_refPrimFlow
          | Src2Prim cs_primAssign
          | Src2Prim cs_primStore[f] _DF DF cs_primLoad[f]
          | Src2Prim cs_primPrimFlow

Ref2Sink :: cs_refSinkFlow
          | cs_refStore[*] _DF DF Ref2Sink

Src2Sink :: Src2Ref Ref2Sink
          | Src2Prim cs_primSinkFlow
          | Src2Prim cs_primStore[*] _DF DF Ref2Sink
