How to read an analysis name, if formatted as 1-2-3-4:5.cfg:

1st part: field sensitivity
  i : field-(i)nsensitive
  s : fully field-(s)ensitive
      fields are the primary context-free dimension

2nd part: call sensitivity
  i : calling context-(i)nsensitive
  s : fully calling context-(s)ensitive
      call strings are the primary context-free dimension
  r : index (r)elation-based k-CFA call-string approximation
  e : graph (e)xplosion-based k-CFA call-string approximation

3rd part: alias formulation
  p : (p)oints-to based
      points-to facts computed for each abstract object, then connected to form
      alias relations
  v : intermediate (v)ariable based
      no abstract objects used, connect alias subpaths at the first common
      variable
  t : (t)ype filters, implemented as edge predicates

4th part: taint flow formulation:
  s : only (s)tart and finish of flow covered (passthroughs ignored)
  a : (a)lias piggyback
  c : (c)onditional flow annotations supported
  e : (e)xploded labels (for the non-primary sensitivity dimension)
  n : (almost) full (n)esting
      no nesting support for conditional escaping trigger entry
  l : (l)imited nested taint propagation
      tainting, escaping, conditional escaping taint entry: all fields
      passthrough entry & exit: only array elements
      conditional escaping trigger entry: no nesting support

5th part: additional parameters:
  r : the analysis agrees on the parametricity of terminals with analyses based
      on relation indices for implementing k-CFA (implicit if 'r' is present in
      the 2nd part)
  a : the analysis uses (or supports) special terminals for array operations,
      rather than constant tags on the specification
  e : the analysis agrees on the parametricity of terminals with analyses using
      exploded labels (implicit if 'e' is present in the 4th part)
  p : PN-style matching
  b : original formulation, with no optimizations
  m : multi-mode RSM formulation (requires normalization before processing)
      both fully recursive boxes and inlinable references on transitions

Other features (not currently covered):
- Modeling of arbitrary object instantiation inside missing code
