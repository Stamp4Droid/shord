# fields:
# - fully field-(s)ensitive
# calls:
# - (k)-CFA call-string approximation
# points-to formulation:
# - (t)ype filters
# - (h)eap-graph
# - (e)xplosion-less formulation
#   using indices for context
# taint flow formulation:
# - (c)ontextified labels
# - (a)lias piggyback
# - generic (l)abel-flow based
# - (l)imited nested taint propagation
#   tainting, escaping, conditional escaping: all fields
#   passthrough entry & exit: only array elements

# Missing:
# - Modeling of arbitrary object instantiation inside missing code
# - Nesting support for conditional escaping trigger entry

# Points-to rules
FlowsTo[c] :: new[c]
            | FlowsTo[*] statStoreRef statLoadRef varCtxt[c]
            | T1[k] loadRef[f] .concat(c,f,k)
T1[k] :: InstFldFT[f] FlowsTo[c] .concat(c,f,k)
InstFldFT[f] :: T2[k] _FlowsTo[c] .concat(c,f,k)
T2[k] :: FlowsTo[c] storeRef[f] .concat(c,f,k)
ArrElemFT :: FlowsTo[c] arrStoreRef _FlowsTo[c]

# Type-filtered points-to rules
FTImm[c] :: FlowsTo[c] asgnRef
          | FlowsTo[b] paramRef[i] .cic(b,i,c)
          | FlowsTo[d] retRef[i] .cic(c,i,d)
FlowsTo[c] :: FTImm[c] // TypeCompat

# Passthrough entry
Obj2Ref[c] :: FlowsTo[c] ref2Ref
	    | ArrElemFT Obj2Ref[c]
Obj2Prim[c] :: FlowsTo[c] ref2Prim
	     | ArrElemFT Obj2Prim[c]

# Label flow
Label2Ref[c] :: Label2Obj FlowsTo[c]
LabelObjIn :: label2Ref[c] _FlowsTo[c]
	    | LabelObjIn _InstFldFT[*]
XferObjOut :: Label2Obj Obj2Ref[c] _FlowsTo[c]
	    | Label2PrimArrEl Obj2Ref[c] _FlowsTo[c]
	    | Label2Prim[c] prim2Ref _FlowsTo[c]
	    | XferObjOut _ArrElemFT
Label2Obj :: LabelObjIn
	   | XferObjOut

Label2Prim[c] :: label2Prim[c]
               | Label2Prim[c] asgnPrim
               | Label2Prim[b] paramPrim[i] .cic(b,i,c)
               | Label2Prim[d] retPrim[i] .cic(c,i,d)
               | Label2Prim[*] statStorePrim statLoadPrim varCtxt[c]
               | T3[k] loadPrim[f] .concat(c,f,k)
	       | LabelObjIn FlowsTo[c] loadPrim[*]
	       | XferObjOut FlowsTo[c] arrLoadPrim
	       | Label2Obj Obj2Prim[c]
	       | Label2PrimArrEl Obj2Prim[c]
	       | Label2Prim[c] prim2Prim
T3[k] :: Label2PrimFld[f] FlowsTo[c] .concat(c,f,k)
Label2PrimFld[f] :: T4[k] _FlowsTo[c] .concat(c,f,k)
T4[k] :: Label2Prim[c] storePrim[f] .concat(c,f,k)
Label2PrimArrEl :: Label2Prim[c] arrStorePrim _FlowsTo[c]

# Escape flow
Obj2Sink :: FlowsTo[c] _label2Ref[c] sinkLabel
	  | FlowsTo[c] ref2SinkByRef _Label2Ref[c] sinkLabel
	  | FlowsTo[c] ref2SinkByPrim _Label2Prim[c] sinkLabel
	  | InstFldFT[*] Obj2Sink
Prim2Sink[c] :: _label2Prim[c] sinkLabel
	      | prim2SinkByRef _Label2Ref[c] sinkLabel
	      | prim2SinkByPrim _Label2Prim[c] sinkLabel

# Complete flow
Src2Sink :: srcLabel Label2Obj Obj2Sink
	  | srcLabel Label2PrimFld[*] Obj2Sink
	  | srcLabel Label2Prim[c] Prim2Sink[c]
.paths Src2Sink 1

# Type compatibility
TypeCompat :: typeFlow typeFlow
.lazy TypeCompat
